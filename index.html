<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hub Ligi Zawodniczej</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f0f0f;
            --bg-card: #1a1a1a;
            --bg-card-hover: #242424;
            --border: #2a2a2a;
            --text-primary: #e8e8e8;
            --text-secondary: #888;
            --text-muted: #555;
            --accent-gold: #c9a227;
            --accent-gold-dim: #8b7019;
            --accent-steel: #7a8b99;
            --success: #4a9f4a;
            --danger: #9f4a4a;
            --info: #4a7a9f;
            --gold-medal: #ffd700;
            --silver-medal: #c0c0c0;
            --bronze-medal: #cd7f32;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Source Sans 3', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .app-container { max-width: 1400px; margin: 0 auto; padding: 20px; }

        header {
            text-align: center;
            padding: 40px 20px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 30px;
            position: relative;
        }

        header::before {
            content: '⚔';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            opacity: 0.3;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            font-weight: 600;
            color: var(--accent-gold);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .subtitle { color: var(--text-secondary); font-weight: 300; font-size: 1.1rem; }

        nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 12px 24px;
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nav-btn:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
            border-color: var(--text-muted);
        }

        .nav-btn.active {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        .weapon-selector { display: flex; justify-content: center; gap: 20px; margin-bottom: 30px; }

        .weapon-btn {
            background: transparent;
            border: 2px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 20px;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .weapon-btn:hover { border-color: var(--accent-steel); color: var(--text-primary); }
        .weapon-btn.active { border-color: var(--accent-gold); color: var(--accent-gold); }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 24px;
            margin-bottom: 20px;
        }

        .card-title {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--accent-gold);
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stats-grid {
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            gap: 16px;
        }

        .stats-grid > * {
            -webkit-box-flex: 1;
            -ms-flex: 1 1 150px;
            flex: 1 1 150px;
            min-width: 150px;
        }

        @supports (display: grid) {
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            .stats-grid > * {
                min-width: auto;
            }
        }

        .stat-item {
            text-align: center;
            padding: 16px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: var(--accent-gold);
            font-family: 'Cinzel', serif;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }

        th {
            text-align: left;
            padding: 12px 8px;
            border-bottom: 2px solid var(--accent-gold-dim);
            color: var(--accent-gold);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 1px;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        th:hover { color: var(--accent-gold); background: var(--bg-card-hover); }
        th.sorted { background: var(--bg-card-hover); }
        th.no-sort { cursor: default; }
        th.no-sort:hover { background: transparent; }

        td {
            padding: 12px 8px;
            border-bottom: 1px solid var(--border);
            color: var(--text-primary);
        }

        tr:hover td { background: var(--bg-card-hover); }

        .fencer-name { font-weight: 500; color: var(--text-primary); }

        .rating-display { display: flex; align-items: center; gap: 8px; }
        .rating-value { font-weight: 600; color: var(--accent-gold); }
        .rating-rd { font-size: 0.75rem; color: var(--text-muted); }

        .metric-bar {
            width: 60px;
            height: 6px;
            background: var(--bg-dark);
            border-radius: 3px;
            overflow: hidden;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }

        .metric-bar-fill {
            height: 100%;
            background: var(--accent-gold);
            transition: width 0.3s ease;
        }

        .filter-row {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        select, input {
            background: #0f0f0f;
            background: var(--bg-dark);
            border: 1px solid #2a2a2a;
            border: 1px solid var(--border);
            color: #e8e8e8;
            color: var(--text-primary);
            padding: 10px 14px;
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.9rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border-radius: 0;
        }

        /* Custom dropdown arrow for better cross-browser support */
        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #8b7019;
            border-color: var(--accent-gold-dim);
        }

        label {
            color: var(--text-secondary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .filter-group { display: flex; flex-direction: column; gap: 6px; }

        .btn {
            background: var(--accent-gold);
            border: none;
            color: var(--bg-dark);
            padding: 12px 24px;
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }

        .btn:hover { background: #ddb32e; }
        .btn:disabled { background: var(--text-muted); cursor: not-allowed; }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
        }

        .btn-secondary:hover { background: var(--accent-gold); color: var(--bg-dark); }

        .btn-refresh {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 16px;
            font-size: 0.8rem;
        }

        .btn-refresh:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: transparent;
        }

        .matchup-list { display: flex; flex-direction: column; gap: 8px; }

        .matchup-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
        }

        .matchup-number { width: 30px; color: var(--text-muted); font-weight: 600; }
        .matchup-vs { color: var(--accent-gold); margin: 0 12px; font-weight: 600; }
        .matchup-context { margin-left: auto; font-size: 0.8rem; color: var(--text-secondary); }

        .fencer-checkbox-grid {
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .fencer-checkbox-grid > * {
            -webkit-box-flex: 1;
            -ms-flex: 1 1 220px;
            flex: 1 1 220px;
            min-width: 220px;
            max-width: 100%;
        }

        @supports (display: grid) {
            .fencer-checkbox-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            }
            .fencer-checkbox-grid > * {
                min-width: auto;
                max-width: none;
            }
        }

        .fencer-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .fencer-checkbox:hover { border-color: var(--text-muted); background: var(--bg-card-hover); }
        .fencer-checkbox.selected { border-color: var(--accent-gold); background: rgba(201, 162, 39, 0.1); }

        .checkbox-indicator {
            width: 20px;
            height: 20px;
            min-width: 20px;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: transparent;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .fencer-checkbox.selected .checkbox-indicator {
            border-color: var(--accent-gold);
            background: var(--accent-gold);
            color: var(--bg-dark);
        }

        .fencer-checkbox-name { flex: 1; font-weight: 500; }

        .last-tournament {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 2px 6px;
            background: var(--bg-card);
            border-radius: 3px;
        }

        .personal-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .personal-name { font-family: 'Cinzel', serif; font-size: 2rem; color: var(--accent-gold); }
        .personal-rating { font-size: 1.5rem; color: var(--text-primary); }
        .personal-rating span { font-size: 0.9rem; color: var(--text-secondary); }

        .personal-rank { font-size: 1.2rem; padding: 4px 12px; border-radius: 4px; font-weight: 600; }
        .rank-1 { color: var(--gold-medal); background: rgba(255, 215, 0, 0.15); }
        .rank-2 { color: var(--silver-medal); background: rgba(192, 192, 192, 0.15); }
        .rank-3 { color: var(--bronze-medal); background: rgba(205, 127, 50, 0.15); }
        .rank-other { color: var(--text-muted); }

        .active-badge {
            padding: 4px 10px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 3px;
        }

        .active-badge.active { background: rgba(74, 159, 74, 0.2); color: var(--success); border: 1px solid var(--success); }
        .active-badge.inactive { background: rgba(136, 136, 136, 0.2); color: var(--text-secondary); border: 1px solid var(--text-secondary); }
        .active-badge.banned { background: rgba(159, 74, 74, 0.2); color: var(--danger); border: 1px solid var(--danger); }

        .chart-container { height: 300px; position: relative; margin: 20px 0; }
        .chart-svg { width: 100%; height: 100%; }
        .chart-line { fill: none; stroke: var(--accent-gold); stroke-width: 2; }
        .chart-area { fill: url(#goldGradient); opacity: 0.3; }
        .chart-dot { fill: var(--accent-gold); }
        .chart-label { fill: var(--text-secondary); font-size: 11px; }

        .radar-container { display: flex; justify-content: center; align-items: center; padding: 20px; }
        .radar-svg { max-width: 350px; max-height: 350px; }
        .radar-polygon { fill: rgba(201, 162, 39, 0.2); stroke: var(--accent-gold); stroke-width: 2; }
        .radar-grid { fill: none; stroke: var(--border); stroke-width: 1; }
        .radar-axis { stroke: var(--border); stroke-width: 1; }
        .radar-label { fill: var(--text-primary); font-size: 12px; font-weight: 600; }
        .radar-value { fill: var(--accent-gold); font-size: 10px; }

        .h2h-grid { overflow-x: auto; }
        .h2h-table { min-width: 100%; }
        .h2h-table th, .h2h-table td { text-align: center; min-width: 60px; }
        .h2h-cell { font-weight: 600; }
        .h2h-positive { color: var(--success); }
        .h2h-negative { color: var(--danger); }
        .h2h-neutral { color: var(--text-secondary); }

        .loading { text-align: center; padding: 60px; color: var(--text-secondary); }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent-gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .error {
            background: rgba(159, 74, 74, 0.2);
            border: 1px solid var(--danger);
            padding: 20px;
            color: var(--text-primary);
            text-align: center;
        }

        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            font-weight: 700;
            font-size: 0.85rem;
        }

        .rank-badge.rank-1 { color: var(--gold-medal); }
        .rank-badge.rank-2 { color: var(--silver-medal); }
        .rank-badge.rank-3 { color: var(--bronze-medal); }

        .fights-table-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .fights-table {
            width: 100%;
            border-collapse: collapse;
        }

        .fights-table th {
            position: sticky;
            top: 0;
            background: var(--bg-card);
            z-index: 1;
        }

        .fights-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }

        .fight-winner-cell { color: var(--success); font-weight: 500; }
        .fight-loser-cell { color: var(--text-secondary); }
        .fight-score-cell { color: var(--accent-gold); font-weight: 600; text-align: center; }
        .fight-prob-cell { text-align: center; }
        .fight-rating-change { font-size: 0.85rem; }
        .rating-up { color: var(--success); }
        .rating-down { color: var(--danger); }

        .two-column-layout {
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            gap: 20px;
            -webkit-box-align: start;
            -ms-flex-align: start;
            align-items: flex-start;
        }

        .two-column-layout > * {
            -webkit-box-flex: 1;
            -ms-flex: 1 1 400px;
            flex: 1 1 400px;
            min-width: 300px;
        }

        @supports (display: grid) {
            .two-column-layout {
                display: grid;
                grid-template-columns: 1fr 1fr;
            }
            .two-column-layout > * {
                min-width: auto;
            }
        }

        .metric-legend {
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #2a2a2a;
            border-top: 1px solid var(--border);
        }

        .metric-legend > * {
            -webkit-box-flex: 1;
            -ms-flex: 1 1 200px;
            flex: 1 1 200px;
            min-width: 200px;
        }

        @supports (display: grid) {
            .metric-legend {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
            .metric-legend > * {
                min-width: auto;
            }
        }

        .metric-legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; }
        .metric-legend-code { font-weight: 600; color: var(--accent-gold); min-width: 40px; }
        .metric-legend-desc { color: var(--text-secondary); }

        .recent-fights-container {
            max-height: 450px;
            overflow-y: auto;
        }

        .recent-fights-table {
            width: 100%;
            border-collapse: collapse;
        }

        .recent-fights-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border);
        }

        .recent-fights-table .col-winner { width: 120px; color: var(--success); font-weight: 500; }
        .recent-fights-table .col-score { width: 70px; text-align: center; color: var(--accent-gold); font-weight: 600; }
        .recent-fights-table .col-loser { width: 120px; color: var(--text-secondary); }
        .recent-fights-table .col-doubles { width: 100px; text-align: right; color: var(--text-muted); font-size: 0.85rem; }
        .recent-fights-table .col-tournament { width: 80px; text-align: right; color: var(--text-muted); font-size: 0.85rem; }

        @media (max-width: 1000px) {
            .two-column-layout { grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.8rem; }
            .app-container { padding: 10px; }
            .card { padding: 16px; }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .nav-btn { padding: 10px 16px; font-size: 0.85rem; }
            table { font-size: 0.8rem; }
            th, td { padding: 8px 4px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // ==================== CONFIGURATION ====================
        const SPREADSHEET_ID = '1oUMn0rjjlmkkfZay965z9AWuYwvtCjHA0LqV4iUBcVM';
        const MAX_POINTS = 5;

        const SHEET_CONFIG = {
            'Fencers': 0,
            'Fights_Longsword': 455682972,
            'Fights_Saber': 986988196
        };

        // Multiple CORS proxies for fallback (in order of preference)
        const CORS_PROXIES = [
            { url: 'https://api.codetabs.com/v1/proxy?quest=', encode: true },
            { url: 'https://corsproxy.org/?', encode: true }
        ];

        const METRIC_DESCRIPTIONS = {
            'EFF': 'Wygrywaj więcej',
            'REL': 'Traf i nie bądź trafionym',
            'MOS': 'Nie niedoceniaj przeciwnika',
            'CLU': 'Nie poddawaj się bez walki',
            'DBL': 'Przemyśl swoje decyzje życiowe'
        };

        // ==================== GLICKO-2 RATING SYSTEM ====================
        const GLICKO2 = {
            INITIAL_RATING: 1500,
            INITIAL_RD: 350,
            INITIAL_VOLATILITY: 0.06,
            TAU: 0.5,
            CONVERGENCE_TOLERANCE: 0.000001,

            toGlicko2Scale: (rating) => (rating - 1500) / 173.7178,
            fromGlicko2Scale: (mu) => mu * 173.7178 + 1500,
            toGlicko2RD: (rd) => rd / 173.7178,
            fromGlicko2RD: (phi) => phi * 173.7178,

            g: (phi) => 1 / Math.sqrt(1 + 3 * phi * phi / (Math.PI * Math.PI)),
            E: (mu, muj, phij) => 1 / (1 + Math.exp(-GLICKO2.g(phij) * (mu - muj))),

            winProbability: (ratingA, rdA, ratingB, rdB) => {
                const q = Math.log(10) / 400;
                const gRD = 1 / Math.sqrt(1 + 3 * q * q * (rdA * rdA + rdB * rdB) / (Math.PI * Math.PI));
                return 1 / (1 + Math.pow(10, -gRD * (ratingA - ratingB) / 400));
            },

            calculateNewRating: (player, opponents, outcomes) => {
                const mu = GLICKO2.toGlicko2Scale(player.rating);
                const phi = GLICKO2.toGlicko2RD(player.rd);
                const sigma = player.volatility;

                if (opponents.length === 0) {
                    const newPhi = Math.sqrt(phi * phi + sigma * sigma);
                    return { rating: player.rating, rd: Math.min(GLICKO2.fromGlicko2RD(newPhi), 350), volatility: sigma };
                }

                let v = 0;
                opponents.forEach((opp) => {
                    const muj = GLICKO2.toGlicko2Scale(opp.rating);
                    const phij = GLICKO2.toGlicko2RD(opp.rd);
                    const gPhij = GLICKO2.g(phij);
                    const E = GLICKO2.E(mu, muj, phij);
                    v += gPhij * gPhij * E * (1 - E);
                });
                v = 1 / v;

                let delta = 0;
                opponents.forEach((opp, i) => {
                    const muj = GLICKO2.toGlicko2Scale(opp.rating);
                    const phij = GLICKO2.toGlicko2RD(opp.rd);
                    const gPhij = GLICKO2.g(phij);
                    const E = GLICKO2.E(mu, muj, phij);
                    delta += gPhij * (outcomes[i] - E);
                });
                delta *= v;

                const a = Math.log(sigma * sigma);
                const tau = GLICKO2.TAU;
                
                const f = (x) => {
                    const ex = Math.exp(x);
                    const d2 = delta * delta;
                    const p2 = phi * phi;
                    const num1 = ex * (d2 - p2 - v - ex);
                    const den1 = 2 * Math.pow(p2 + v + ex, 2);
                    return num1 / den1 - (x - a) / (tau * tau);
                };

                let A = a, B;
                if (delta * delta > phi * phi + v) {
                    B = Math.log(delta * delta - phi * phi - v);
                } else {
                    let k = 1;
                    while (f(a - k * tau) < 0) k++;
                    B = a - k * tau;
                }

                let fA = f(A), fB = f(B), iterations = 0;
                while (Math.abs(B - A) > GLICKO2.CONVERGENCE_TOLERANCE && iterations < 100) {
                    const C = A + (A - B) * fA / (fB - fA);
                    const fC = f(C);
                    if (fC * fB <= 0) { A = B; fA = fB; } else { fA = fA / 2; }
                    B = C; fB = fC; iterations++;
                }

                const newSigma = Math.exp(B / 2);
                const phiStar = Math.sqrt(phi * phi + newSigma * newSigma);
                const newPhi = 1 / Math.sqrt(1 / (phiStar * phiStar) + 1 / v);
                
                let newMu = mu;
                opponents.forEach((opp, i) => {
                    const muj = GLICKO2.toGlicko2Scale(opp.rating);
                    const phij = GLICKO2.toGlicko2RD(opp.rd);
                    const gPhij = GLICKO2.g(phij);
                    const E = GLICKO2.E(mu, muj, phij);
                    newMu += newPhi * newPhi * gPhij * (outcomes[i] - E);
                });

                return { rating: GLICKO2.fromGlicko2Scale(newMu), rd: GLICKO2.fromGlicko2RD(newPhi), volatility: newSigma };
            }
        };

        // ==================== DATA FETCHING ====================
        // Normalize column names to handle differences between local and web fetching
        const normalizeData = (data) => {
            if (!data || data.length === 0) return data;

            // Map of possible column name variations to standard names
            const columnMappings = {
                'tournament': ['tournament', 'Tournament', 'turniej', 'Turniej'],
                'winner': ['winner', 'Winner', 'zwyciezca', 'Zwyciezca', 'zwycięzca', 'Zwycięzca'],
                'loser': ['loser', 'Loser', 'przegrany', 'Przegrany'],
                'winner_points': ['winner_points', 'Winner_points', 'winner_Points', 'Winner_Points', 'winnerpoints', 'WinnerPoints'],
                'loser_points': ['loser_points', 'Loser_points', 'loser_Points', 'Loser_Points', 'loserpoints', 'LoserPoints'],
                'double_hits': ['double_hits', 'Double_hits', 'double_Hits', 'Double_Hits', 'doublehits', 'DoubleHits', 'doubles', 'Doubles', 'duble', 'Duble'],
                'name': ['name', 'Name', 'imie', 'Imie', 'imię', 'Imię', 'nazwisko', 'Nazwisko'],
                'ban': ['ban', 'Ban', 'BAN', 'banned', 'Banned'],
                'timestamp': ['timestamp', 'Timestamp', 'czas', 'Czas', 'data', 'Data']
            };

            // Helper to clean a key (remove quotes, trim whitespace)
            const cleanKey = (k) => k.replace(/^["']|["']$/g, '').trim().toLowerCase();

            return data.map(row => {
                const normalizedRow = {};
                const rowKeys = Object.keys(row);

                // For each standard column name, find the matching key in the row
                for (const [standardName, variations] of Object.entries(columnMappings)) {
                    for (const variation of variations) {
                        const variationClean = variation.toLowerCase();
                        // Check for exact match, trimmed match, or cleaned match (without quotes)
                        const foundKey = rowKeys.find(k =>
                            k === variation ||
                            k.trim() === variation ||
                            k.toLowerCase() === variationClean ||
                            k.trim().toLowerCase() === variationClean ||
                            cleanKey(k) === variationClean
                        );
                        if (foundKey && row[foundKey] !== undefined) {
                            // Also clean the value (remove surrounding quotes if present)
                            let value = row[foundKey];
                            if (typeof value === 'string') {
                                value = value.replace(/^["']|["']$/g, '').trim();
                            }
                            normalizedRow[standardName] = value;
                            break;
                        }
                    }
                }

                // Also copy any other columns that weren't mapped
                for (const key of rowKeys) {
                    const cleanedKey = cleanKey(key);
                    const standardKey = Object.keys(columnMappings).find(std =>
                        columnMappings[std].some(v => v.toLowerCase() === cleanedKey)
                    );
                    if (!standardKey && !normalizedRow[key] && !normalizedRow[cleanedKey]) {
                        let value = row[key];
                        if (typeof value === 'string') {
                            value = value.replace(/^["']|["']$/g, '').trim();
                        }
                        normalizedRow[key.trim()] = value;
                    }
                }

                return normalizedRow;
            });
        };

        const fetchSheetData = async (sheetName) => {
            const gid = SHEET_CONFIG[sheetName];

            // Try CORS proxies
            const exportUrl = `https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}/export?format=csv&gid=${gid}`;
            let lastError = null;

            for (const proxy of CORS_PROXIES) {
                try {
                    const url = proxy.encode ? proxy.url + encodeURIComponent(exportUrl) : proxy.url + exportUrl;
                    console.log(`[${sheetName}] Trying proxy:`, proxy.url);
                    const response = await fetch(url, {
                        headers: {
                            'Accept': 'text/csv,text/plain,*/*'
                        }
                    });
                    if (!response.ok) {
                        lastError = new Error(`HTTP ${response.status}`);
                        console.log(`[${sheetName}] Proxy failed:`, response.status);
                        continue;
                    }
                    const text = await response.text();
                    if (text.includes('<!DOCTYPE html>') || text.includes('<html')) {
                        lastError = new Error('Otrzymano HTML zamiast CSV');
                        console.log(`[${sheetName}] Proxy returned HTML instead of CSV`);
                        continue;
                    }
                    const parsed = Papa.parse(text, { header: true, skipEmptyLines: true }).data;
                    console.log(`[${sheetName}] SUCCESS via proxy. Columns:`, parsed.length > 0 ? Object.keys(parsed[0]) : 'empty');
                    if (parsed.length > 0) {
                        console.log(`[${sheetName}] Sample row:`, parsed[0]);
                    }
                    return normalizeData(parsed);
                } catch (err) {
                    lastError = err;
                    console.log(`[${sheetName}] Proxy error:`, err.message);
                    continue;
                }
            }
            throw new Error(`Nie udało się pobrać ${sheetName}. ${lastError?.message || 'Sprawdź czy arkusz jest opublikowany do sieci (Plik > Udostępnij > Opublikuj w internecie).'}`);
        };

        // ==================== ANALYTICS ====================
        const calculateFencerStats = (fencer, fights, tournamentFilter = 'all') => {
            let filtered = tournamentFilter === 'all' ? fights : fights.filter(f => f.tournament === tournamentFilter);
            const fencerFights = filtered.filter(f => f.winner === fencer || f.loser === fencer);
            const wins = fencerFights.filter(f => f.winner === fencer);
            const losses = fencerFights.filter(f => f.loser === fencer);

            const totalFights = fencerFights.length;
            const winCount = wins.length;
            const lossCount = losses.length;

            const cleanHitsDealt = wins.reduce((sum, f) => sum + parseInt(f.winner_points || 0), 0) +
                                   losses.reduce((sum, f) => sum + parseInt(f.loser_points || 0), 0);
            const cleanHitsReceived = wins.reduce((sum, f) => sum + parseInt(f.loser_points || 0), 0) +
                                      losses.reduce((sum, f) => sum + parseInt(f.winner_points || 0), 0);
            const hitsLost = wins.reduce((sum, f) => sum + parseInt(f.loser_points || 0), 0);
            const hitsSnatched = losses.reduce((sum, f) => sum + parseInt(f.loser_points || 0), 0);
            const doubleHits = fencerFights.reduce((sum, f) => sum + parseInt(f.double_hits || 0), 0);

            const effectiveness = totalFights > 0 ? winCount / totalFights : 0;
            const reliability = cleanHitsReceived > 0 ? cleanHitsDealt / cleanHitsReceived : cleanHitsDealt > 0 ? 999 : 1;
            const avgHitsLostPerWin = winCount > 0 ? hitsLost / winCount : 0;
            const providence = (MAX_POINTS - avgHitsLostPerWin) / MAX_POINTS;
            const fierceness = lossCount === 0 ? 1 : hitsSnatched / (lossCount * (MAX_POINTS - 1));
            const doublicity = cleanHitsDealt > 0 ? doubleHits / cleanHitsDealt : 0;

            return {
                fencer, fights: totalFights, wins: winCount, losses: lossCount,
                cleanHitsDealt, cleanHitsReceived, hitsLost, hitsSnatched, doubleHits,
                effectiveness, reliability: Math.min(reliability, 10), providence, fierceness, doublicity
            };
        };

        // Calculate ratings with per-tournament tracking (not per-fight)
        const calculateGlicko2RatingsWithHistory = (fights, fencers) => {
            const tournaments = [...new Set(fights.map(f => f.tournament))].sort();
            const ratings = {};
            const tournamentRatingChanges = {}; // Track rating changes per fencer per tournament

            fencers.forEach(f => {
                ratings[f.name] = { rating: GLICKO2.INITIAL_RATING, rd: GLICKO2.INITIAL_RD, volatility: GLICKO2.INITIAL_VOLATILITY, history: [] };
            });

            tournaments.forEach(tournament => {
                const tournamentFights = fights.filter(f => f.tournament === tournament);
                const participants = new Set();
                tournamentFights.forEach(f => { participants.add(f.winner); participants.add(f.loser); });

                // Store ratings before tournament
                const ratingsBeforeTournament = {};
                participants.forEach(fencer => {
                    if (!ratings[fencer]) {
                        ratings[fencer] = { rating: GLICKO2.INITIAL_RATING, rd: GLICKO2.INITIAL_RD, volatility: GLICKO2.INITIAL_VOLATILITY, history: [] };
                    }
                    ratingsBeforeTournament[fencer] = { rating: ratings[fencer].rating, rd: ratings[fencer].rd };
                });

                // Calculate new ratings for all participants
                participants.forEach(fencer => {
                    const fencerFights = tournamentFights.filter(f => f.winner === fencer || f.loser === fencer);
                    const opponents = [], outcomes = [];

                    fencerFights.forEach(fight => {
                        const isWinner = fight.winner === fencer;
                        const opponentName = isWinner ? fight.loser : fight.winner;
                        const oppRating = ratingsBeforeTournament[opponentName] || { rating: GLICKO2.INITIAL_RATING, rd: GLICKO2.INITIAL_RD };
                        opponents.push({ rating: oppRating.rating, rd: oppRating.rd });
                        const winnerPoints = parseInt(fight.winner_points) || MAX_POINTS;
                        const loserPoints = parseInt(fight.loser_points) || 0;
                        const margin = (winnerPoints - loserPoints) / MAX_POINTS;
                        outcomes.push(isWinner ? 0.5 + margin * 0.25 : 0.5 - margin * 0.25);
                    });

                    const newRating = GLICKO2.calculateNewRating(ratings[fencer], opponents, outcomes);
                    const ratingChange = newRating.rating - ratings[fencer].rating;
                    
                    // Store rating change for this tournament
                    if (!tournamentRatingChanges[fencer]) tournamentRatingChanges[fencer] = {};
                    tournamentRatingChanges[fencer][tournament] = ratingChange;
                    
                    ratings[fencer] = { ...newRating, history: [...ratings[fencer].history, { tournament, rating: newRating.rating, rd: newRating.rd, ratingChange }] };
                });

                // Decay RD for non-participants
                Object.keys(ratings).forEach(fencer => {
                    if (!participants.has(fencer) && ratings[fencer].history.length > 0) {
                        const phi = GLICKO2.toGlicko2RD(ratings[fencer].rd);
                        const sigma = ratings[fencer].volatility;
                        ratings[fencer].rd = Math.min(GLICKO2.fromGlicko2RD(Math.sqrt(phi * phi + sigma * sigma)), 350);
                    }
                });
            });

            // Build fight details with win probability (but NO rating delta per fight)
            const fightDetails = fights.map(fight => {
                const tournament = fight.tournament;
                const tournamentFights = fights.filter(f => f.tournament === tournament);
                const tournamentIndex = tournaments.indexOf(tournament);
                
                // Get ratings from BEFORE this tournament
                let winnerRating = GLICKO2.INITIAL_RATING, winnerRd = GLICKO2.INITIAL_RD;
                let loserRating = GLICKO2.INITIAL_RATING, loserRd = GLICKO2.INITIAL_RD;
                
                if (tournamentIndex > 0 && ratings[fight.winner]?.history) {
                    const prevHistory = ratings[fight.winner].history.filter(h => tournaments.indexOf(h.tournament) < tournamentIndex);
                    if (prevHistory.length > 0) {
                        const last = prevHistory[prevHistory.length - 1];
                        winnerRating = last.rating;
                        winnerRd = last.rd;
                    }
                }
                if (tournamentIndex > 0 && ratings[fight.loser]?.history) {
                    const prevHistory = ratings[fight.loser].history.filter(h => tournaments.indexOf(h.tournament) < tournamentIndex);
                    if (prevHistory.length > 0) {
                        const last = prevHistory[prevHistory.length - 1];
                        loserRating = last.rating;
                        loserRd = last.rd;
                    }
                }

                const winProb = GLICKO2.winProbability(winnerRating, winnerRd, loserRating, loserRd);

                return {
                    ...fight,
                    winnerRatingBefore: winnerRating,
                    loserRatingBefore: loserRating,
                    winProbability: winProb
                };
            });

            return { ratings, fightDetails, tournamentRatingChanges };
        };

        const calculateHeadToHead = (fencer, fights) => {
            const h2h = {};
            fights.forEach(fight => {
                if (fight.winner === fencer) {
                    if (!h2h[fight.loser]) h2h[fight.loser] = { wins: 0, losses: 0 };
                    h2h[fight.loser].wins++;
                } else if (fight.loser === fencer) {
                    if (!h2h[fight.winner]) h2h[fight.winner] = { wins: 0, losses: 0 };
                    h2h[fight.winner].losses++;
                }
            });
            return h2h;
        };

        const getRankings = (fights, fencers, ratings) => {
            return fencers.filter(f => fights.some(fight => fight.winner === f.name || fight.loser === f.name))
                .map(f => ({ ...calculateFencerStats(f.name, fights, 'all'), rating: ratings[f.name]?.rating || GLICKO2.INITIAL_RATING, rd: ratings[f.name]?.rd || GLICKO2.INITIAL_RD }))
                .filter(s => s.fights > 0).sort((a, b) => b.rating - a.rating);
        };

        // ==================== FENCER STATUS ====================
        const getFencerStatus = (fencerName, fencerData, fights, allTournaments) => {
            // Get the most recent tournament (last in sorted order)
            const mostRecentTournament = allTournaments.length > 0 ? allTournaments[allTournaments.length - 1] : null;

            // Check if banned (ban column contains the most recent tournament name)
            if (fencerData?.ban && mostRecentTournament && fencerData.ban.trim() === mostRecentTournament) {
                return 'banned';
            }

            // Get last 3 tournaments
            const last3Tournaments = allTournaments.slice(-3);

            // Check if fencer participated in any of the last 3 tournaments
            const fencerFights = fights.filter(f => f.winner === fencerName || f.loser === fencerName);
            const participatedInRecent = fencerFights.some(f => last3Tournaments.includes(f.tournament));

            return participatedInRecent ? 'active' : 'inactive';
        };

        // ==================== MATCHUP GENERATION ====================
        const generateMatchups = (attendingFencers, fights) => {
            const n = attendingFencers.length;
            if (n <= 6) {
                const matchups = [];
                for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) matchups.push([attendingFencers[i], attendingFencers[j]]);
                return optimizeMatchupOrder(matchups, fights);
            }

            const fightsPerFencer = n % 2 === 0 ? 5 : 6;
            const recentFights = {};
            const lastNTournaments = [...new Set(fights.map(f => f.tournament))].sort().slice(-5);
            fights.filter(f => lastNTournaments.includes(f.tournament)).forEach(fight => {
                const key = [fight.winner, fight.loser].sort().join('|');
                recentFights[key] = (recentFights[key] || 0) + 1;
            });

            const possibleMatchups = [];
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const key = [attendingFencers[i], attendingFencers[j]].sort().join('|');
                    possibleMatchups.push({ fencers: [attendingFencers[i], attendingFencers[j]], priority: 100 - (recentFights[key] || 0) * 20 });
                }
            }
            possibleMatchups.sort((a, b) => b.priority - a.priority);

            const selectedMatchups = [];
            const fightCounts = {};
            attendingFencers.forEach(f => fightCounts[f] = 0);

            for (const matchup of possibleMatchups) {
                const [f1, f2] = matchup.fencers;
                if (fightCounts[f1] < fightsPerFencer && fightCounts[f2] < fightsPerFencer) {
                    selectedMatchups.push(matchup.fencers);
                    fightCounts[f1]++;
                    fightCounts[f2]++;
                }
                if (attendingFencers.every(f => fightCounts[f] >= fightsPerFencer)) break;
            }
            return optimizeMatchupOrder(selectedMatchups, fights);
        };

        const optimizeMatchupOrder = (matchups, historicalFights) => {
            const ordered = [];
            const remaining = [...matchups];

            while (remaining.length > 0) {
                let bestIndex = 0, bestScore = -Infinity;
                for (let i = 0; i < remaining.length; i++) {
                    const [f1, f2] = remaining[i];
                    let score = 0;
                    if (ordered.length > 0) {
                        const last = ordered[ordered.length - 1];
                        if (last.includes(f1) || last.includes(f2)) score -= 10000;
                    }
                    if (ordered.length > 1) {
                        const prev = ordered[ordered.length - 2];
                        if (prev.includes(f1) || prev.includes(f2)) score -= 100;
                    }
                    if (score > bestScore) { bestScore = score; bestIndex = i; }
                }
                ordered.push(remaining[bestIndex]);
                remaining.splice(bestIndex, 1);
            }

            const recentFights = {};
            const lastNTournaments = [...new Set(historicalFights.map(f => f.tournament))].sort().slice(-5);
            historicalFights.filter(f => lastNTournaments.includes(f.tournament)).forEach(fight => {
                const key = [fight.winner, fight.loser].sort().join('|');
                recentFights[key] = (recentFights[key] || 0) + 1;
            });

            return ordered.map(([f1, f2]) => {
                const key = [f1, f2].sort().join('|');
                const count = recentFights[key] || 0;
                const context = count === 0 ? 'Nowe zestawienie!' : count === 1 ? 'Walczyli raz' : `Walczyli ${count}x`;
                return { fencers: [f1, f2], context };
            });
        };

        // ==================== COMPONENTS ====================
        const Loading = () => (<div className="loading"><div className="loading-spinner"></div><div>Ładowanie danych turnieju...</div></div>);
        
        const ErrorDisplay = ({ message }) => (
            <div className="error">
                <strong>Błąd ładowania danych</strong>
                <p style={{marginTop: 10}}>{message}</p>
            </div>
        );

        const MetricLegend = () => (
            <div className="metric-legend">
                {Object.entries(METRIC_DESCRIPTIONS).map(([code, desc]) => (
                    <div key={code} className="metric-legend-item">
                        <span className="metric-legend-code">{code}%</span>
                        <span className="metric-legend-desc">{desc}</span>
                    </div>
                ))}
            </div>
        );

        const StatsGrid = ({ fights, tournamentFilter }) => {
            const filtered = tournamentFilter === 'all' ? fights : fights.filter(f => f.tournament === tournamentFilter);
            const totalFights = filtered.length;
            const totalDoubles = filtered.reduce((sum, f) => sum + parseInt(f.double_hits || 0), 0);
            const uniqueFencers = new Set([...filtered.map(f => f.winner), ...filtered.map(f => f.loser)]).size;
            const avgDoubles = totalFights > 0 ? (totalDoubles / totalFights).toFixed(1) : 0;

            return (
                <div className="card">
                    <div className="card-title">Podsumowanie</div>
                    <div className="stats-grid">
                        <div className="stat-item"><div className="stat-value">{totalFights}</div><div className="stat-label">Walki</div></div>
                        <div className="stat-item"><div className="stat-value">{uniqueFencers}</div><div className="stat-label">Zawodnicy</div></div>
                        <div className="stat-item"><div className="stat-value">{totalDoubles}</div><div className="stat-label">Duble</div></div>
                        <div className="stat-item"><div className="stat-value">{avgDoubles}</div><div className="stat-label">Śr. Dubli/Walkę</div></div>
                    </div>
                </div>
            );
        };

        const RecentFights = ({ fights }) => {
            const recent = [...fights].reverse().slice(0, 10);
            const formatDoubles = (count) => {
                const n = parseInt(count) || 0;
                if (n === 0) return 'brak dubli';
                if (n === 1) return '1 dubel';
                if (n >= 2 && n <= 4) return `${n} duble`;
                return `${n} dubli`;
            };

            return (
                <div className="card">
                    <div className="card-title">Ostatnie Walki</div>
                    <div className="recent-fights-container">
                        <table className="recent-fights-table">
                            <tbody>
                                {recent.map((fight, i) => (
                                    <tr key={i}>
                                        <td className="col-winner">{fight.winner}</td>
                                        <td className="col-score">{fight.winner_points} - {fight.loser_points}</td>
                                        <td className="col-loser">{fight.loser}</td>
                                        <td className="col-doubles">{formatDoubles(fight.double_hits)}</td>
                                        <td className="col-tournament">{fight.tournament}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        // Tournament Fights Table - uses numerical doubles, no rating delta
        const TournamentFightsTable = ({ fightDetails, tournamentFilter }) => {
            const filtered = fightDetails.filter(f => f.tournament === tournamentFilter);

            return (
                <div className="card">
                    <div className="card-title">Walki</div>
                    <div className="fights-table-container">
                        <table className="fights-table">
                            <thead>
                                <tr>
                                    <th className="no-sort">Zwycięzca</th>
                                    <th className="no-sort">Wynik</th>
                                    <th className="no-sort">Przegrany</th>
                                    <th className="no-sort">Duble</th>
                                    <th className="no-sort">P(win)</th>
                                </tr>
                            </thead>
                            <tbody>
                                {filtered.map((fight, i) => (
                                    <tr key={i}>
                                        <td className="fight-winner-cell">{fight.winner}</td>
                                        <td className="fight-score-cell">{fight.winner_points} - {fight.loser_points}</td>
                                        <td className="fight-loser-cell">{fight.loser}</td>
                                        <td>{parseInt(fight.double_hits) || 0}</td>
                                        <td className="fight-prob-cell">{(fight.winProbability * 100).toFixed(0)}%</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        // Fencer Fights Table - no rating delta
        const FencerFightsTable = ({ fencer, fightDetails }) => {
            const fencerFights = fightDetails.filter(f => f.winner === fencer || f.loser === fencer).reverse();
            
            if (fencerFights.length === 0) return null;

            return (
                <div className="card">
                    <div className="card-title">Historia Walk</div>
                    <div className="fights-table-container">
                        <table className="fights-table">
                            <thead>
                                <tr>
                                    <th className="no-sort">Turniej</th>
                                    <th className="no-sort">Przeciwnik</th>
                                    <th className="no-sort">Wynik</th>
                                    <th className="no-sort">Duble</th>
                                    <th className="no-sort">P(win)</th>
                                </tr>
                            </thead>
                            <tbody>
                                {fencerFights.map((fight, i) => {
                                    const isWinner = fight.winner === fencer;
                                    const opponent = isWinner ? fight.loser : fight.winner;
                                    const result = isWinner ? 'W' : 'L';
                                    const score = isWinner ? `${fight.winner_points} - ${fight.loser_points}` : `${fight.loser_points} - ${fight.winner_points}`;
                                    const winProb = isWinner ? fight.winProbability : (1 - fight.winProbability);
                                    
                                    return (
                                        <tr key={i}>
                                            <td>{fight.tournament}</td>
                                            <td className={isWinner ? 'fight-winner-cell' : 'fight-loser-cell'}>
                                                {result} vs {opponent}
                                            </td>
                                            <td className="fight-score-cell">{score}</td>
                                            <td>{parseInt(fight.double_hits) || 0}</td>
                                            <td className="fight-prob-cell">{(winProb * 100).toFixed(0)}%</td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const RankingsTable = ({ fights, fencers, ratings, tournamentFilter, tournaments }) => {
            const [sortBy, setSortBy] = useState('rating');
            const [sortDir, setSortDir] = useState('desc');
            const sortedTournaments = useMemo(() => [...(tournaments || [])].sort(), [tournaments]);

            const stats = useMemo(() => {
                return fencers.filter(f => {
                    const status = getFencerStatus(f.name, f, fights, sortedTournaments);
                    return status === 'active' || fights.some(fight => fight.winner === f.name || fight.loser === f.name);
                })
                    .map(f => ({ ...calculateFencerStats(f.name, fights, tournamentFilter), rating: ratings[f.name]?.rating || GLICKO2.INITIAL_RATING, rd: ratings[f.name]?.rd || GLICKO2.INITIAL_RD }))
                    .filter(s => s.fights > 0);
            }, [fights, fencers, ratings, tournamentFilter, sortedTournaments]);

            const sorted = useMemo(() => [...stats].sort((a, b) => sortDir === 'desc' ? b[sortBy] - a[sortBy] : a[sortBy] - b[sortBy]), [stats, sortBy, sortDir]);

            const handleSort = (column) => {
                if (sortBy === column) setSortDir(sortDir === 'desc' ? 'asc' : 'desc');
                else { setSortBy(column); setSortDir('desc'); }
            };

            const formatDoublicity = (val) => val > 1 ? '>100%' : `${(val * 100).toFixed(0)}%`;

            return (
                <div className="card">
                    <div className="card-title">Rankingi</div>
                    <div style={{ overflowX: 'auto' }}>
                        <table>
                            <thead>
                                <tr>
                                    <th className="no-sort">#</th>
                                    <th className="no-sort">Zawodnik</th>
                                    <th onClick={() => handleSort('rating')} className={sortBy === 'rating' ? 'sorted' : ''}>Rating{sortBy === 'rating' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('fights')} className={sortBy === 'fights' ? 'sorted' : ''}>Walki{sortBy === 'fights' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('wins')} className={sortBy === 'wins' ? 'sorted' : ''}>W{sortBy === 'wins' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('losses')} className={sortBy === 'losses' ? 'sorted' : ''}>L{sortBy === 'losses' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('effectiveness')} className={sortBy === 'effectiveness' ? 'sorted' : ''}>EFF%{sortBy === 'effectiveness' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('reliability')} className={sortBy === 'reliability' ? 'sorted' : ''}>REL{sortBy === 'reliability' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('providence')} className={sortBy === 'providence' ? 'sorted' : ''}>MOS{sortBy === 'providence' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('fierceness')} className={sortBy === 'fierceness' ? 'sorted' : ''}>CLU{sortBy === 'fierceness' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                    <th onClick={() => handleSort('doublicity')} className={sortBy === 'doublicity' ? 'sorted' : ''}>DBL%{sortBy === 'doublicity' && (sortDir === 'desc' ? ' ↓' : ' ↑')}</th>
                                </tr>
                            </thead>
                            <tbody>
                                {sorted.map((s, i) => (
                                    <tr key={s.fencer}>
                                        <td><span className={`rank-badge ${i < 3 ? `rank-${i + 1}` : ''}`}>{i + 1}</span></td>
                                        <td className="fencer-name">{s.fencer}</td>
                                        <td><div className="rating-display"><span className="rating-value">{Math.round(s.rating)}</span><span className="rating-rd">±{Math.round(s.rd)}</span></div></td>
                                        <td>{s.fights}</td>
                                        <td>{s.wins}</td>
                                        <td>{s.losses}</td>
                                        <td>{(s.effectiveness * 100).toFixed(0)}%<div className="metric-bar"><div className="metric-bar-fill" style={{ width: `${s.effectiveness * 100}%` }} /></div></td>
                                        <td>{s.reliability.toFixed(2)}</td>
                                        <td>{(s.providence * 100).toFixed(0)}%</td>
                                        <td>{(s.fierceness * 100).toFixed(0)}%</td>
                                        <td>{formatDoublicity(s.doublicity)}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    <MetricLegend />
                </div>
            );
        };

        const RatingChart = ({ history }) => {
            if (!history || history.length < 2) return <div className="card"><div className="card-title">Historia Ratingu</div><p style={{color: 'var(--text-secondary)'}}>Za mało danych</p></div>;

            const width = 600, height = 250;
            const padding = { top: 20, right: 20, bottom: 40, left: 50 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            const ratings = history.map(h => h.rating);
            const rds = history.map(h => h.rd);
            const minRating = Math.min(...ratings.map((r, i) => r - rds[i])) - 50;
            const maxRating = Math.max(...ratings.map((r, i) => r + rds[i])) + 50;

            const xScale = (i) => padding.left + (i / (history.length - 1)) * chartWidth;
            const yScale = (r) => padding.top + chartHeight - ((r - minRating) / (maxRating - minRating)) * chartHeight;

            const linePath = history.map((h, i) => `${i === 0 ? 'M' : 'L'} ${xScale(i)} ${yScale(h.rating)}`).join(' ');
            const areaPath = history.map((h, i) => `${i === 0 ? 'M' : 'L'} ${xScale(i)} ${yScale(h.rating + h.rd)}`).join(' ') +
                            history.map((h, i) => `L ${xScale(history.length - 1 - i)} ${yScale(history[history.length - 1 - i].rating - history[history.length - 1 - i].rd)}`).join(' ') + ' Z';

            return (
                <div className="card">
                    <div className="card-title">Historia Ratingu</div>
                    <div className="chart-container">
                        <svg className="chart-svg" viewBox={`0 0 ${width} ${height}`}>
                            <defs><linearGradient id="goldGradient" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stopColor="#c9a227" stopOpacity="0.4" /><stop offset="100%" stopColor="#c9a227" stopOpacity="0" /></linearGradient></defs>
                            {[0, 0.25, 0.5, 0.75, 1].map(pct => (<g key={pct}><line x1={padding.left} y1={padding.top + chartHeight * pct} x2={width - padding.right} y2={padding.top + chartHeight * pct} stroke="var(--border)" strokeDasharray="4,4" /><text x={padding.left - 8} y={padding.top + chartHeight * pct + 4} textAnchor="end" className="chart-label">{Math.round(maxRating - (maxRating - minRating) * pct)}</text></g>))}
                            <path d={areaPath} className="chart-area" />
                            <path d={linePath} className="chart-line" />
                            {history.map((h, i) => (<circle key={i} cx={xScale(i)} cy={yScale(h.rating)} r="4" className="chart-dot" />))}
                            {history.map((h, i) => (<text key={i} x={xScale(i)} y={height - 10} textAnchor="middle" className="chart-label">{h.tournament}</text>))}
                        </svg>
                    </div>
                </div>
            );
        };

        // FIXED: DBL radar chart - max changed to 1.0 for proper scaling
        const RadarChart = ({ stats }) => {
            const metrics = [
                { key: 'effectiveness', label: 'EFF', max: 1 },
                { key: 'reliability', label: 'REL', max: 3 },
                { key: 'providence', label: 'MOS', max: 1 },
                { key: 'fierceness', label: 'CLU', max: 1 },
                { key: 'doublicity', label: 'DBL', max: 1.0, invert: true }  // FIXED: max=1.0 for proper 0-100% scaling
            ];

            const size = 300, center = size / 2, radius = 100, levels = 5;

            const getPoint = (index, value, maxValue, invert = false) => {
                const angle = (Math.PI * 2 * index) / metrics.length - Math.PI / 2;
                let normalizedValue = Math.min(value / maxValue, 1);
                // For DBL: 0% = best = full circle, 100% = worst = empty
                if (invert) normalizedValue = 1 - normalizedValue;
                const r = radius * normalizedValue;
                return { x: center + r * Math.cos(angle), y: center + r * Math.sin(angle) };
            };

            const getLabelPoint = (index) => {
                const angle = (Math.PI * 2 * index) / metrics.length - Math.PI / 2;
                const r = radius + 30;
                return { x: center + r * Math.cos(angle), y: center + r * Math.sin(angle) };
            };

            const polygonPoints = metrics.map((m, i) => {
                const point = getPoint(i, stats[m.key] || 0, m.max, m.invert);
                return `${point.x},${point.y}`;
            }).join(' ');

            const formatValue = (key, value) => {
                if (key === 'reliability') return value.toFixed(2);
                if (key === 'doublicity' && value > 1) return '>100%';
                return `${(value * 100).toFixed(0)}%`;
            };

            return (
                <div className="card">
                    <div className="card-title">Profil Metryczny</div>
                    <div className="radar-container">
                        <svg className="radar-svg" viewBox={`0 0 ${size} ${size}`}>
                            {[...Array(levels)].map((_, i) => (<circle key={i} cx={center} cy={center} r={radius * ((i + 1) / levels)} className="radar-grid" />))}
                            {metrics.map((_, i) => { const angle = (Math.PI * 2 * i) / metrics.length - Math.PI / 2; return (<line key={i} x1={center} y1={center} x2={center + radius * Math.cos(angle)} y2={center + radius * Math.sin(angle)} className="radar-axis" />); })}
                            <polygon points={polygonPoints} className="radar-polygon" />
                            {metrics.map((m, i) => {
                                const point = getLabelPoint(i);
                                const value = stats[m.key] || 0;
                                return (<g key={i}><text x={point.x} y={point.y - 8} textAnchor="middle" className="radar-label">{m.label}</text><text x={point.x} y={point.y + 8} textAnchor="middle" className="radar-value">{formatValue(m.key, value)}</text></g>);
                            })}
                        </svg>
                    </div>
                    <MetricLegend />
                </div>
            );
        };

        // Tournament Record - now includes rating delta
        const TournamentRecord = ({ fencer, fights, ratings }) => {
            const tournaments = [...new Set(fights.map(f => f.tournament))].sort().reverse();
            const fencerHistory = ratings[fencer]?.history || [];
            
            const records = tournaments.map(t => { 
                const stats = calculateFencerStats(fencer, fights, t); 
                if (stats.fights === 0) return null;
                
                // Find rating change for this tournament
                const historyEntry = fencerHistory.find(h => h.tournament === t);
                const ratingChange = historyEntry?.ratingChange || 0;
                
                return { tournament: t, ...stats, ratingChange }; 
            }).filter(Boolean);
            
            if (records.length === 0) return <div className="card"><div className="card-title">Historia Turniejów</div><p style={{color: 'var(--text-secondary)'}}>Brak danych</p></div>;

            const formatDoublicity = (val) => val > 1 ? '>100%' : `${(val * 100).toFixed(0)}%`;
            const formatRatingChange = (change) => {
                const rounded = Math.round(change);
                if (rounded >= 0) return <span className="rating-up">+{rounded}</span>;
                return <span className="rating-down">{rounded}</span>;
            };

            return (
                <div className="card">
                    <div className="card-title">Historia Turniejów</div>
                    <div style={{ overflowX: 'auto' }}>
                        <table>
                            <thead><tr>
                                <th className="no-sort">Turniej</th>
                                <th className="no-sort">Walki</th>
                                <th className="no-sort">W</th>
                                <th className="no-sort">L</th>
                                <th className="no-sort">EFF%</th>
                                <th className="no-sort">REL</th>
                                <th className="no-sort">MOS</th>
                                <th className="no-sort">CLU</th>
                                <th className="no-sort">DBL%</th>
                                <th className="no-sort">Δ Rating</th>
                            </tr></thead>
                            <tbody>
                                {records.map(r => (
                                    <tr key={r.tournament}>
                                        <td>{r.tournament}</td>
                                        <td>{r.fights}</td>
                                        <td>{r.wins}</td>
                                        <td>{r.losses}</td>
                                        <td>{(r.effectiveness * 100).toFixed(0)}%<div className="metric-bar"><div className="metric-bar-fill" style={{ width: `${r.effectiveness * 100}%` }} /></div></td>
                                        <td>{r.reliability.toFixed(2)}</td>
                                        <td>{(r.providence * 100).toFixed(0)}%</td>
                                        <td>{(r.fierceness * 100).toFixed(0)}%</td>
                                        <td>{formatDoublicity(r.doublicity)}</td>
                                        <td className="fight-rating-change">{formatRatingChange(r.ratingChange)}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const HeadToHeadTable = ({ fencer, fights }) => {
            const h2h = calculateHeadToHead(fencer, fights);
            const opponents = Object.keys(h2h).sort((a, b) => (h2h[b].wins + h2h[b].losses) - (h2h[a].wins + h2h[a].losses));
            if (opponents.length === 0) return <div className="card"><div className="card-title">Head-to-Head</div><p style={{color: 'var(--text-secondary)'}}>Brak danych</p></div>;

            return (
                <div className="card">
                    <div className="card-title">Head-to-Head</div>
                    <div className="h2h-grid">
                        <table className="h2h-table">
                            <thead><tr><th className="no-sort">Przeciwnik</th><th className="no-sort">W</th><th className="no-sort">L</th><th className="no-sort">Bilans</th></tr></thead>
                            <tbody>
                                {opponents.map(opp => {
                                    const record = h2h[opp];
                                    const diff = record.wins - record.losses;
                                    return (<tr key={opp}><td>{opp}</td><td>{record.wins}</td><td>{record.losses}</td><td className={`h2h-cell ${diff > 0 ? 'h2h-positive' : diff < 0 ? 'h2h-negative' : 'h2h-neutral'}`}>{diff > 0 ? '+' : ''}{diff}</td></tr>);
                                })}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const PersonalStatsPage = ({ fights, fencers, ratings, fightDetails, tournaments }) => {
            const [selectedFencer, setSelectedFencer] = useState('');
            const activeFencers = useMemo(() => fencers.filter(f => fights.some(fight => fight.winner === f.name || fight.loser === f.name)).map(f => f.name).sort(), [fencers, fights]);
            const rankings = useMemo(() => getRankings(fights, fencers, ratings), [fights, fencers, ratings]);
            const sortedTournaments = useMemo(() => [...tournaments].sort(), [tournaments]);

            useEffect(() => { if (activeFencers.length > 0 && !selectedFencer) setSelectedFencer(activeFencers[0]); }, [activeFencers]);

            const stats = selectedFencer ? calculateFencerStats(selectedFencer, fights, 'all') : null;
            const fencerRating = ratings[selectedFencer];
            const fencerData = fencers.find(f => f.name === selectedFencer);
            const fencerStatus = getFencerStatus(selectedFencer, fencerData, fights, sortedTournaments);
            const rank = rankings.findIndex(r => r.fencer === selectedFencer) + 1;
            const getRankDisplay = () => {
                if (rank === 1) return { text: '🥇 1.', className: 'rank-1' };
                if (rank === 2) return { text: '🥈 2.', className: 'rank-2' };
                if (rank === 3) return { text: '🥉 3.', className: 'rank-3' };
                return { text: `${rank}.`, className: 'rank-other' };
            };
            const rankDisplay = getRankDisplay();

            return (
                <div>
                    <div className="filter-row">
                        <div className="filter-group">
                            <label>Wybierz Zawodnika</label>
                            <select value={selectedFencer} onChange={(e) => setSelectedFencer(e.target.value)}>
                                {activeFencers.map(f => (<option key={f} value={f}>{f}</option>))}
                            </select>
                        </div>
                    </div>

                    {selectedFencer && stats && (
                        <>
                            <div className="personal-header">
                                <div className="personal-name">{selectedFencer}</div>
                                <span className={`active-badge ${fencerStatus}`}>
                                    {fencerStatus === 'active' ? 'Aktywny' : fencerStatus === 'banned' ? 'Zbanowany' : 'Nieaktywny'}
                                </span>
                                <div className="personal-rating">{Math.round(fencerRating?.rating || 1500)}<span> ±{Math.round(fencerRating?.rd || 350)} Rating</span></div>
                                <div className={`personal-rank ${rankDisplay.className}`}>{rankDisplay.text}</div>
                            </div>

                            <div className="stats-grid" style={{ marginBottom: 20 }}>
                                <div className="stat-item"><div className="stat-value">{stats.fights}</div><div className="stat-label">Walki</div></div>
                                <div className="stat-item"><div className="stat-value">{stats.wins}-{stats.losses}</div><div className="stat-label">W-L</div></div>
                                <div className="stat-item"><div className="stat-value">{(stats.effectiveness * 100).toFixed(0)}%</div><div className="stat-label">Win Rate</div></div>
                                <div className="stat-item"><div className="stat-value">{stats.cleanHitsDealt}</div><div className="stat-label">Trafienia</div></div>
                                <div className="stat-item"><div className="stat-value">{stats.cleanHitsReceived}</div><div className="stat-label">Otrzymane</div></div>
                                <div className="stat-item"><div className="stat-value">{stats.doubleHits}</div><div className="stat-label">Duble</div></div>
                            </div>

                            <div className="two-column-layout">
                                <RadarChart stats={stats} />
                                <RatingChart history={fencerRating?.history || []} />
                            </div>

                            <FencerFightsTable fencer={selectedFencer} fightDetails={fightDetails} />
                            <TournamentRecord fencer={selectedFencer} fights={fights} ratings={ratings} />
                            <HeadToHeadTable fencer={selectedFencer} fights={fights} />
                        </>
                    )}
                </div>
            );
        };

        const TournamentPage = ({ fights, fencers, ratings, fightDetails, tournamentFilter, setTournamentFilter, tournaments }) => (
            <div>
                <div className="filter-row">
                    <div className="filter-group">
                        <label>Turniej</label>
                        <select value={tournamentFilter} onChange={(e) => setTournamentFilter(e.target.value)}>
                            <option value="all">Wszystkie Turnieje</option>
                            {tournaments.map(t => (<option key={t} value={t}>{t}</option>))}
                        </select>
                    </div>
                </div>
                <StatsGrid fights={fights} tournamentFilter={tournamentFilter} />
                <RankingsTable fights={fights} fencers={fencers} ratings={ratings} tournamentFilter={tournamentFilter} tournaments={tournaments} />
                {tournamentFilter !== 'all' && (
                    <TournamentFightsTable fightDetails={fightDetails} tournamentFilter={tournamentFilter} />
                )}
            </div>
        );

        const MatchupGeneratorPage = ({ fights, fencers, tournaments }) => {
            const [selectedFencers, setSelectedFencers] = useState([]);
            const [generatedMatchups, setGeneratedMatchups] = useState([]);
            const sortedTournaments = useMemo(() => [...tournaments].sort(), [tournaments]);
            // Show fencers who are active (participated in last 3 tournaments) and not banned
            const activeFencers = useMemo(() => fencers.filter(f => {
                const status = getFencerStatus(f.name, f, fights, sortedTournaments);
                return status === 'active';
            }).map(f => f.name).sort(), [fencers, fights, sortedTournaments]);

            const getLastTournament = (fencer) => {
                const fencerFights = fights.filter(f => f.winner === fencer || f.loser === fencer);
                if (fencerFights.length === 0) return 'NOWY';
                return fencerFights.map(f => f.tournament).sort().pop();
            };

            const toggleFencer = (fencer) => { setSelectedFencers(prev => prev.includes(fencer) ? prev.filter(f => f !== fencer) : [...prev, fencer]); setGeneratedMatchups([]); };
            const selectAll = () => { setSelectedFencers([...activeFencers]); setGeneratedMatchups([]); };
            const selectNone = () => { setSelectedFencers([]); setGeneratedMatchups([]); };
            const generate = () => { if (selectedFencers.length < 2) { alert('Wybierz co najmniej 2 zawodników'); return; } setGeneratedMatchups(generateMatchups(selectedFencers, fights)); };
            const copyToClipboard = () => { navigator.clipboard.writeText(generatedMatchups.map((m, i) => `${i + 1}. ${m.fencers[0]} vs ${m.fencers[1]}`).join('\n')); };

            return (
                <div>
                    <div className="card">
                        <div className="card-title">Wybierz Obecnych Zawodników</div>
                        <div style={{ marginBottom: 16, display: 'flex', gap: 8, flexWrap: 'wrap', alignItems: 'center' }}>
                            <button className="btn btn-secondary" onClick={selectAll}>Zaznacz Wszystkich</button>
                            <button className="btn btn-secondary" onClick={selectNone}>Odznacz</button>
                            <span style={{ marginLeft: 16, color: 'var(--text-secondary)' }}>{selectedFencers.length} wybranych</span>
                        </div>
                        <div className="fencer-checkbox-grid">
                            {activeFencers.map(fencer => (
                                <div key={fencer} className={`fencer-checkbox ${selectedFencers.includes(fencer) ? 'selected' : ''}`} onClick={() => toggleFencer(fencer)}>
                                    <span className="checkbox-indicator">✓</span>
                                    <span className="fencer-checkbox-name">{fencer}</span>
                                    <span className="last-tournament">{getLastTournament(fencer)}</span>
                                </div>
                            ))}
                        </div>
                        <button className="btn" onClick={generate} disabled={selectedFencers.length < 2}>Losuj Walki</button>
                    </div>

                    {generatedMatchups.length > 0 && (
                        <div className="card">
                            <div className="card-title"><span>Wylosowane Walki ({generatedMatchups.length})</span><button className="btn btn-secondary" onClick={copyToClipboard} style={{ padding: '6px 12px', fontSize: '0.8rem' }}>Kopiuj</button></div>
                            <div className="matchup-list">
                                {generatedMatchups.map((matchup, i) => (
                                    <div key={i} className="matchup-item">
                                        <span className="matchup-number">{i + 1}.</span>
                                        <span>{matchup.fencers[0]}</span>
                                        <span className="matchup-vs">vs</span>
                                        <span>{matchup.fencers[1]}</span>
                                        <span className="matchup-context">{matchup.context}</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const DashboardPage = ({ fights, fencers, ratings, tournaments }) => (
            <div>
                <StatsGrid fights={fights} tournamentFilter="all" />
                <div className="two-column-layout">
                    <RecentFights fights={fights} />
                    <RankingsTable fights={fights} fencers={fencers} ratings={ratings} tournamentFilter="all" tournaments={tournaments} />
                </div>
            </div>
        );

        const App = () => {
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [fencers, setFencers] = useState([]);
            const [longswordFights, setLongswordFights] = useState([]);
            const [saberFights, setSaberFights] = useState([]);
            const [activeTab, setActiveTab] = useState('dashboard');
            const [weapon, setWeapon] = useState('longsword');
            const [tournamentFilter, setTournamentFilter] = useState('all');
            const [refreshKey, setRefreshKey] = useState(0);

            const loadData = useCallback(async () => {
                setLoading(true); setError(null);
                try {
                    const [fencersData, longswordData, saberData] = await Promise.all([fetchSheetData('Fencers'), fetchSheetData('Fights_Longsword'), fetchSheetData('Fights_Saber')]);
                    setFencers(fencersData); setLongswordFights(longswordData); setSaberFights(saberData); setLoading(false);
                } catch (err) { setError(err.message); setLoading(false); }
            }, []);

            useEffect(() => { loadData(); }, [loadData, refreshKey]);

            const fights = weapon === 'longsword' ? longswordFights : saberFights;
            const tournaments = useMemo(() => [...new Set(fights.map(f => f.tournament))].sort().reverse(), [fights]);
            const { ratings, fightDetails } = useMemo(() => calculateGlicko2RatingsWithHistory(fights, fencers), [fights, fencers]);

            if (loading) return <Loading />;
            if (error) return <ErrorDisplay message={error} />;

            return (
                <div className="app-container">
                    <header><h1>Hub Ligi Zawodniczej</h1><div className="subtitle">HEMA • KSF</div></header>
                    <nav>
                        {[{ key: 'dashboard', label: 'Dashboard' }, { key: 'tournaments', label: 'Turnieje' }, { key: 'personal', label: 'Zawodnicy' }, { key: 'matchups', label: 'Losuj Walki' }].map(tab => (
                            <button key={tab.key} className={`nav-btn ${activeTab === tab.key ? 'active' : ''}`} onClick={() => setActiveTab(tab.key)}>{tab.label}</button>
                        ))}
                        <button className="btn-refresh" onClick={() => setRefreshKey(k => k + 1)}>↻ Odśwież</button>
                    </nav>
                    <div className="weapon-selector">
                        <button className={`weapon-btn ${weapon === 'longsword' ? 'active' : ''}`} onClick={() => setWeapon('longsword')}>⚔ Miecz Długi</button>
                        <button className={`weapon-btn ${weapon === 'saber' ? 'active' : ''}`} onClick={() => setWeapon('saber')}>🗡 Szabla</button>
                    </div>

                    {activeTab === 'dashboard' && <DashboardPage fights={fights} fencers={fencers} ratings={ratings} tournaments={tournaments} />}
                    {activeTab === 'tournaments' && <TournamentPage fights={fights} fencers={fencers} ratings={ratings} fightDetails={fightDetails} tournamentFilter={tournamentFilter} setTournamentFilter={setTournamentFilter} tournaments={tournaments} />}
                    {activeTab === 'personal' && <PersonalStatsPage fights={fights} fencers={fencers} ratings={ratings} fightDetails={fightDetails} tournaments={tournaments} />}
                    {activeTab === 'matchups' && <MatchupGeneratorPage fights={fights} fencers={fencers} tournaments={tournaments} />}

                    <footer style={{ textAlign: 'center', padding: '40px 20px', marginTop: 40, borderTop: '1px solid var(--border)', color: 'var(--text-muted)', fontSize: '0.85rem' }}>
                        <p>Źródło danych: <a href={`https://docs.google.com/spreadsheets/d/${SPREADSHEET_ID}`} target="_blank" style={{ color: 'var(--accent-gold-dim)' }}>Google Sheets</a></p>
                        <p style={{ marginTop: 8 }}>Glicko-2 Rating System • Built for wpierdol</p>
                    </footer>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
